# Rustの所有権

そのまえに...
## スタックとヒープというメモリ領域について
---
レストランで例える

## 変数スコープ
---
変数を設定→変数がスコープに入った。メモリが割り当てられる。

変数がスコープを抜ける{}から抜ける→変数がスコープから抜けた(割り当てたメモリが開放される)

## 変数とデータの相互作用法: ムーブ
---
スタックに保管される型(数値型など)以外の型(String型など)変数を別の変数に再代入する(加工済みverを用意しようとしたなど)と所有権が再代入先の変数に移行し元の変数は使えなくなる。
これがムーブ

## 変数とデータの相互作用法: クローン
---
cloneメソッドを使えば想定のコピーができるよ

## 所有権と関数
---
関数の引数に変数を渡すと関数に所有権が移って元の変数は使えなくなるよ
→元の変数も使えるようには？

## 参照と借用
---
&を使うと所有権をもらうことなく変数を使えるよ
ポインタのポインタ

## 可変な参照
---
普通に参照しても、参照はデフォルトで不変です。
ある変数をメソッドに渡して加工したい場合は、
&mut variable
とすることで加工可能な参照をメソッドに渡せる

(同じスコープ内で)複数の可変な参照は作れない。可変な参照と不変な参照は共存できない。不変な参照は何個でもつくれる(一つの不変な参照は他の参照に影響を与えない)

## ダグリングポインタ(宙に浮いた参照)
ダグリングポインタの説明
メモリが確保されているデータ、そのメモリに対するポインタがある。
メモリが開放されたあとに残るポインタ、これがダグリングポインタ、このポインタが参照するデータはもう存在していない(null)、この状態のポインタをメソッド等で参照してしまうとNullPointerException(通称ぬるぽ)が発生してしまう
ダグリングポインタは重大なバグ(ぬるぽ等)を引き起こす可能性があるのでrustでは参照がスコープを抜けるまでデータがスコープを抜けることがないようにエラーを投げてくれる。