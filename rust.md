# 今読んでいる書籍
<img src="https://images-na.ssl-images-amazon.com/images/I/71YeXAUPopL.jpg" width=50%>

---
## RUSTという言語について

- とにかく実行速度が早い
- モダンな文法が一通り入っている
- OSからWebアプリケーションまで幅広く実装できる


など

<br />

# とにかく実行速度が早い
<img src="https://benchmarksgame-team.pages.debian.net/benchmarksgame/q6600/download/fastest.svg" width=50%>

<br />

- ## Rustはガベージコレクションを持たない

<br />

普通プログラムはメモリ領域を確保、解放しながら計算処理をおこなう。

メモリ領域を長時間確保するとメモリ領域が減ってしまうので、

ガベージコレクションという処理を挟んで不要なメモリを解放している。

<br />

- ## C言語やC++も同様にガベージコレクションを持たない

<br />
これらは手動でメモリを確保し、手動でメモリを解放する。

しかし、解放し忘れたり二重で解放したり。→「メモリ安全ではない」状態

## ➡Rustでは「所有権」「借用」「ライフタイム」という仕組み

<br />

- プログラマが直接メモリ管理をする必要が無い
- ガベージコレクタにメモリ管理を任せる必要がない

<br />

「所有権」「借用」「ライフタイム」については次回

<br />

# モダンな文法が一通り入っている

- ## 変数が標準で不変

```rust
fn main() {
    let x = 5; //変数が標準で不変(immmutable)になる

    x = 6; //これはコンパイルエラーになる
}
```

```rust
fn main() {
    let mut x = 5; //mutを付けると可変(mutable)になる

    x = 6; //代入ができる
}
```

- ## 型推論
型注釈を必要としない
```rust
fn main() {
    let mut v = vec![]; //この時点では Vec<?> という型

    v.push(1); // ここで変数v は i32という型になった
}
```

ちなみに`i32`とは数値型。

- `i` →符号あり整数型

- `32` →32ビット環境

```rust
// 変数:型名で型の指定
let a:i8 = 8; // 8bit整数型
let b:i16 = 16; // 16ビット整数型
let c:i32 = 32; // 32ビット整数型
let d:i64 = 64; // 64ビット整数型
let e:i128 = 128; //128ビット整数型
```
符号ありなしや整数のサイズを細かく指定できる
